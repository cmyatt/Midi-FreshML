(* Midi-FreshML typechecker tests. *)

(* Test name and type declarations (nty and dty grammar rules):
    -> Single and multiple names       - Done
    -> Single type, multiple ctors     - Done
    -> Single type, single ctor        - Done
    -> Multiple type, multiple ctors   - Done
    -> name decl followed by type decl - Done
    -> name decl followed by name decl - Done
    -> type decl followed by name decl - Done
    -> type decl followed by type decl - Done
*)
name a, b, c;
name d, e;

type exp, typ where
  Bar : string -> typ;

name f;

type pair where
  Pair : int * string -> pair,
  BoolPair : int * bool -> pair;

type test where
  Ctor : real -> real -> test;

(* Test grammar rules:
    -> Identifier                                                          - Done
    -> Literal (int, real, string, bool)                                   - Done
    -> Ctor                                                                - Done
    -> fresh                                                               - Done
    -> if                                                                  - Done
    -> swap                                                                - Done
    -> name abstraction                                                    - Done
    -> unit                                                                - Done
    -> pair                                                                - Done
    -> function abstraction                                                - Done
    -> application                                                         - Done
    -> match (and therefore branch)                                        - Done
    -> pattern (don't care, id, ctor, name abs, unit, pair, parenthesised) - Done
    -> local value declaration                                             - Done
    -> top level declaration                                               - Done
    -> binary operation                                                    - Done
    -> unary operation                                                     - Done
    -> parenthesised expression                                            - Done
*)

(* Test PASSED
    - function abstraction
    - int literals
    - top level let
    - id and pair patterns
    - identifier lookup
    - binary operations
   Expect: type of real * real -> real
*)
let add = fun (x : real * real) -> let (a, b) = x in a + b + b - a * b;

(* Test identifier - PASSED *)
Foo;  (* expect failure reporting expected 1 arg *)
a;    (* expect failure since id 'a' not bound *)
add;  (* expect type real * real -> real *)

(* Test PASSED
    - fresh
    - real literals
    - top level let
    - if
    - swap
    - unary operation
*)

let x = fresh : a;  (* expect type a_name *)
let y = fresh : a;  (* expect type a_name *)
fresh : x;          (* expect error since x not a name type *)
if x = y then swap(x, y) in add (3.0, 4.2) else ~2.9; (* expect real *)

(* Test id re-definition PASSED *)
let x = 5;  (* expect int *)

(* Test PASSED
    - match
    - Ctor application
    - Int, string and bool literals
    - Ctor, id and don't care pattern
   Expect type bool
*)
match Pair(4, "hello") with
| Pair(n, s) -> false
| x -> true
| _ -> true;

(* Test PASSED
    - match
    - Name abs and parenthesised patterns
   Expect type real * real -> real
*)
match <<fresh : b>>(5+2) with
| <<y>>(ex) -> add;

(* Test unit pattern PASSED *)
let () = ();  (* expect unit *)

(* Test PASSED
    - top level let
    - parenthesised expression
    - if
    - fresh
    - recursively defined function
    - application
   Expect type int -> int
*)
let fact (x : int) : int =
  if (fresh : a) = (fresh : a) then 1 else x*fact(x - 1);

(* Test PASSED
    - string literals
    - Name abstraction
    - Pair
   Expect type <<a_name>>(string * string)
*)
let z = <<if y = y then y else fresh : a>>("m", "n");

type test where
  A : test -> test,
  B : test -> test,
  C : int -> test;

match A (B (C 2)) with
| A (B (B x)) -> true
| A (A (B x)) -> true
| A (B (C x)) -> false;

